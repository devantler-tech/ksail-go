// Code generated by mockery; DO NOT EDIT.
// github.com/vektra/mockery
// template: testify

package eksprovisioner

import (
	"context"
	"time"

	"github.com/stretchr/testify/mock"
	"github.com/weaveworks/eksctl/pkg/actions/cluster"
	"github.com/weaveworks/eksctl/pkg/apis/eksctl.io/v1alpha5"
	"github.com/weaveworks/eksctl/pkg/eks"
)

// NewMockEKSProviderConstructor creates a new instance of MockEKSProviderConstructor. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockEKSProviderConstructor(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockEKSProviderConstructor {
	mock := &MockEKSProviderConstructor{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// MockEKSProviderConstructor is an autogenerated mock type for the EKSProviderConstructor type
type MockEKSProviderConstructor struct {
	mock.Mock
}

// NewClusterProvider provides a mock function with given fields: ctx, spec, clusterSpec
func (m *MockEKSProviderConstructor) NewClusterProvider(ctx context.Context, spec *v1alpha5.ProviderConfig, clusterSpec *v1alpha5.ClusterConfig) (*eks.ClusterProvider, error) {
	ret := m.Called(ctx, spec, clusterSpec)

	var r0 *eks.ClusterProvider
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *v1alpha5.ProviderConfig, *v1alpha5.ClusterConfig) (*eks.ClusterProvider, error)); ok {
		return rf(ctx, spec, clusterSpec)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *v1alpha5.ProviderConfig, *v1alpha5.ClusterConfig) *eks.ClusterProvider); ok {
		r0 = rf(ctx, spec, clusterSpec)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*eks.ClusterProvider)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *v1alpha5.ProviderConfig, *v1alpha5.ClusterConfig) error); ok {
		r1 = rf(ctx, spec, clusterSpec)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// NewMockEKSClusterActions creates a new instance of MockEKSClusterActions. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockEKSClusterActions(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockEKSClusterActions {
	mock := &MockEKSClusterActions{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// MockEKSClusterActions is an autogenerated mock type for the EKSClusterActions type
type MockEKSClusterActions struct {
	mock.Mock
}

// Delete provides a mock function with given fields: ctx, waitInterval, podEvictionWaitPeriod, wait, force, disableNodegroupEviction, parallel
func (m *MockEKSClusterActions) Delete(ctx context.Context, waitInterval, podEvictionWaitPeriod time.Duration, wait, force, disableNodegroupEviction bool, parallel int) error {
	ret := m.Called(ctx, waitInterval, podEvictionWaitPeriod, wait, force, disableNodegroupEviction, parallel)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, time.Duration, time.Duration, bool, bool, bool, int) error); ok {
		r0 = rf(ctx, waitInterval, podEvictionWaitPeriod, wait, force, disableNodegroupEviction, parallel)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// NewMockEKSClusterActionsFactory creates a new instance of MockEKSClusterActionsFactory. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockEKSClusterActionsFactory(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockEKSClusterActionsFactory {
	mock := &MockEKSClusterActionsFactory{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// MockEKSClusterActionsFactory is an autogenerated mock type for the EKSClusterActionsFactory type
type MockEKSClusterActionsFactory struct {
	mock.Mock
}

// NewClusterActions provides a mock function with given fields: ctx, cfg, ctl
func (m *MockEKSClusterActionsFactory) NewClusterActions(ctx context.Context, cfg *v1alpha5.ClusterConfig, ctl *eks.ClusterProvider) (EKSClusterActions, error) {
	ret := m.Called(ctx, cfg, ctl)

	var r0 EKSClusterActions
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *v1alpha5.ClusterConfig, *eks.ClusterProvider) (EKSClusterActions, error)); ok {
		return rf(ctx, cfg, ctl)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *v1alpha5.ClusterConfig, *eks.ClusterProvider) EKSClusterActions); ok {
		r0 = rf(ctx, cfg, ctl)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(EKSClusterActions)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *v1alpha5.ClusterConfig, *eks.ClusterProvider) error); ok {
		r1 = rf(ctx, cfg, ctl)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// NewMockEKSClusterLister creates a new instance of MockEKSClusterLister. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockEKSClusterLister(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockEKSClusterLister {
	mock := &MockEKSClusterLister{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// MockEKSClusterLister is an autogenerated mock type for the EKSClusterLister type
type MockEKSClusterLister struct {
	mock.Mock
}

// GetClusters provides a mock function with given fields: ctx, provider, listAllRegions, chunkSize
func (m *MockEKSClusterLister) GetClusters(ctx context.Context, provider *eks.ClusterProvider, listAllRegions bool, chunkSize int) ([]cluster.Description, error) {
	ret := m.Called(ctx, provider, listAllRegions, chunkSize)

	var r0 []cluster.Description
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *eks.ClusterProvider, bool, int) ([]cluster.Description, error)); ok {
		return rf(ctx, provider, listAllRegions, chunkSize)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *eks.ClusterProvider, bool, int) []cluster.Description); ok {
		r0 = rf(ctx, provider, listAllRegions, chunkSize)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]cluster.Description)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *eks.ClusterProvider, bool, int) error); ok {
		r1 = rf(ctx, provider, listAllRegions, chunkSize)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// NewMockEKSClusterCreator creates a new instance of MockEKSClusterCreator. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockEKSClusterCreator(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockEKSClusterCreator {
	mock := &MockEKSClusterCreator{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// MockEKSClusterCreator is an autogenerated mock type for the EKSClusterCreator type
type MockEKSClusterCreator struct {
	mock.Mock
}

// CreateCluster provides a mock function with given fields: ctx, cfg, ctl
func (m *MockEKSClusterCreator) CreateCluster(ctx context.Context, cfg *v1alpha5.ClusterConfig, ctl *eks.ClusterProvider) error {
	ret := m.Called(ctx, cfg, ctl)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, *v1alpha5.ClusterConfig, *eks.ClusterProvider) error); ok {
		r0 = rf(ctx, cfg, ctl)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}