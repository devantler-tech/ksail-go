// Code generated by mockery; DO NOT EDIT.
// github.com/vektra/mockery
// template: testify

package di

import (
	"context"

	"github.com/samber/do/v2"
	mock "github.com/stretchr/testify/mock"
)

// NewMockInjector creates a new instance of MockInjector. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockInjector(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockInjector {
	mock := &MockInjector{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// MockInjector is an autogenerated mock type for the Injector type
type MockInjector struct {
	mock.Mock
}

type MockInjector_Expecter struct {
	mock *mock.Mock
}

func (_m *MockInjector) EXPECT() *MockInjector_Expecter {
	return &MockInjector_Expecter{mock: &_m.Mock}
}

// Ancestors provides a mock function for the type MockInjector
func (_mock *MockInjector) Ancestors() []*do.Scope {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for Ancestors")
	}

	var r0 []*do.Scope
	if returnFunc, ok := ret.Get(0).(func() []*do.Scope); ok {
		r0 = returnFunc()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*do.Scope)
		}
	}
	return r0
}

// MockInjector_Ancestors_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Ancestors'
type MockInjector_Ancestors_Call struct {
	*mock.Call
}

// Ancestors is a helper method to define mock.On call
func (_e *MockInjector_Expecter) Ancestors() *MockInjector_Ancestors_Call {
	return &MockInjector_Ancestors_Call{Call: _e.mock.On("Ancestors")}
}

func (_c *MockInjector_Ancestors_Call) Run(run func()) *MockInjector_Ancestors_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *MockInjector_Ancestors_Call) Return(scopes []*do.Scope) *MockInjector_Ancestors_Call {
	_c.Call.Return(scopes)
	return _c
}

func (_c *MockInjector_Ancestors_Call) RunAndReturn(run func() []*do.Scope) *MockInjector_Ancestors_Call {
	_c.Call.Return(run)
	return _c
}

// ChildByID provides a mock function for the type MockInjector
func (_mock *MockInjector) ChildByID(s string) (*do.Scope, bool) {
	ret := _mock.Called(s)

	if len(ret) == 0 {
		panic("no return value specified for ChildByID")
	}

	var r0 *do.Scope
	var r1 bool
	if returnFunc, ok := ret.Get(0).(func(string) (*do.Scope, bool)); ok {
		return returnFunc(s)
	}
	if returnFunc, ok := ret.Get(0).(func(string) *do.Scope); ok {
		r0 = returnFunc(s)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*do.Scope)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(string) bool); ok {
		r1 = returnFunc(s)
	} else {
		r1 = ret.Get(1).(bool)
	}
	return r0, r1
}

// MockInjector_ChildByID_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ChildByID'
type MockInjector_ChildByID_Call struct {
	*mock.Call
}

// ChildByID is a helper method to define mock.On call
//   - s string
func (_e *MockInjector_Expecter) ChildByID(s interface{}) *MockInjector_ChildByID_Call {
	return &MockInjector_ChildByID_Call{Call: _e.mock.On("ChildByID", s)}
}

func (_c *MockInjector_ChildByID_Call) Run(run func(s string)) *MockInjector_ChildByID_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 string
		if args[0] != nil {
			arg0 = args[0].(string)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *MockInjector_ChildByID_Call) Return(scope *do.Scope, b bool) *MockInjector_ChildByID_Call {
	_c.Call.Return(scope, b)
	return _c
}

func (_c *MockInjector_ChildByID_Call) RunAndReturn(run func(s string) (*do.Scope, bool)) *MockInjector_ChildByID_Call {
	_c.Call.Return(run)
	return _c
}

// ChildByName provides a mock function for the type MockInjector
func (_mock *MockInjector) ChildByName(s string) (*do.Scope, bool) {
	ret := _mock.Called(s)

	if len(ret) == 0 {
		panic("no return value specified for ChildByName")
	}

	var r0 *do.Scope
	var r1 bool
	if returnFunc, ok := ret.Get(0).(func(string) (*do.Scope, bool)); ok {
		return returnFunc(s)
	}
	if returnFunc, ok := ret.Get(0).(func(string) *do.Scope); ok {
		r0 = returnFunc(s)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*do.Scope)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(string) bool); ok {
		r1 = returnFunc(s)
	} else {
		r1 = ret.Get(1).(bool)
	}
	return r0, r1
}

// MockInjector_ChildByName_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ChildByName'
type MockInjector_ChildByName_Call struct {
	*mock.Call
}

// ChildByName is a helper method to define mock.On call
//   - s string
func (_e *MockInjector_Expecter) ChildByName(s interface{}) *MockInjector_ChildByName_Call {
	return &MockInjector_ChildByName_Call{Call: _e.mock.On("ChildByName", s)}
}

func (_c *MockInjector_ChildByName_Call) Run(run func(s string)) *MockInjector_ChildByName_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 string
		if args[0] != nil {
			arg0 = args[0].(string)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *MockInjector_ChildByName_Call) Return(scope *do.Scope, b bool) *MockInjector_ChildByName_Call {
	_c.Call.Return(scope, b)
	return _c
}

func (_c *MockInjector_ChildByName_Call) RunAndReturn(run func(s string) (*do.Scope, bool)) *MockInjector_ChildByName_Call {
	_c.Call.Return(run)
	return _c
}

// Children provides a mock function for the type MockInjector
func (_mock *MockInjector) Children() []*do.Scope {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for Children")
	}

	var r0 []*do.Scope
	if returnFunc, ok := ret.Get(0).(func() []*do.Scope); ok {
		r0 = returnFunc()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*do.Scope)
		}
	}
	return r0
}

// MockInjector_Children_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Children'
type MockInjector_Children_Call struct {
	*mock.Call
}

// Children is a helper method to define mock.On call
func (_e *MockInjector_Expecter) Children() *MockInjector_Children_Call {
	return &MockInjector_Children_Call{Call: _e.mock.On("Children")}
}

func (_c *MockInjector_Children_Call) Run(run func()) *MockInjector_Children_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *MockInjector_Children_Call) Return(scopes []*do.Scope) *MockInjector_Children_Call {
	_c.Call.Return(scopes)
	return _c
}

func (_c *MockInjector_Children_Call) RunAndReturn(run func() []*do.Scope) *MockInjector_Children_Call {
	_c.Call.Return(run)
	return _c
}

// HealthCheck provides a mock function for the type MockInjector
func (_mock *MockInjector) HealthCheck() map[string]error {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for HealthCheck")
	}

	var r0 map[string]error
	if returnFunc, ok := ret.Get(0).(func() map[string]error); ok {
		r0 = returnFunc()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(map[string]error)
		}
	}
	return r0
}

// MockInjector_HealthCheck_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'HealthCheck'
type MockInjector_HealthCheck_Call struct {
	*mock.Call
}

// HealthCheck is a helper method to define mock.On call
func (_e *MockInjector_Expecter) HealthCheck() *MockInjector_HealthCheck_Call {
	return &MockInjector_HealthCheck_Call{Call: _e.mock.On("HealthCheck")}
}

func (_c *MockInjector_HealthCheck_Call) Run(run func()) *MockInjector_HealthCheck_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *MockInjector_HealthCheck_Call) Return(stringToErr map[string]error) *MockInjector_HealthCheck_Call {
	_c.Call.Return(stringToErr)
	return _c
}

func (_c *MockInjector_HealthCheck_Call) RunAndReturn(run func() map[string]error) *MockInjector_HealthCheck_Call {
	_c.Call.Return(run)
	return _c
}

// HealthCheckWithContext provides a mock function for the type MockInjector
func (_mock *MockInjector) HealthCheckWithContext(context1 context.Context) map[string]error {
	ret := _mock.Called(context1)

	if len(ret) == 0 {
		panic("no return value specified for HealthCheckWithContext")
	}

	var r0 map[string]error
	if returnFunc, ok := ret.Get(0).(func(context.Context) map[string]error); ok {
		r0 = returnFunc(context1)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(map[string]error)
		}
	}
	return r0
}

// MockInjector_HealthCheckWithContext_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'HealthCheckWithContext'
type MockInjector_HealthCheckWithContext_Call struct {
	*mock.Call
}

// HealthCheckWithContext is a helper method to define mock.On call
//   - context1 context.Context
func (_e *MockInjector_Expecter) HealthCheckWithContext(context1 interface{}) *MockInjector_HealthCheckWithContext_Call {
	return &MockInjector_HealthCheckWithContext_Call{Call: _e.mock.On("HealthCheckWithContext", context1)}
}

func (_c *MockInjector_HealthCheckWithContext_Call) Run(run func(context1 context.Context)) *MockInjector_HealthCheckWithContext_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *MockInjector_HealthCheckWithContext_Call) Return(stringToErr map[string]error) *MockInjector_HealthCheckWithContext_Call {
	_c.Call.Return(stringToErr)
	return _c
}

func (_c *MockInjector_HealthCheckWithContext_Call) RunAndReturn(run func(context1 context.Context) map[string]error) *MockInjector_HealthCheckWithContext_Call {
	_c.Call.Return(run)
	return _c
}

// ID provides a mock function for the type MockInjector
func (_mock *MockInjector) ID() string {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for ID")
	}

	var r0 string
	if returnFunc, ok := ret.Get(0).(func() string); ok {
		r0 = returnFunc()
	} else {
		r0 = ret.Get(0).(string)
	}
	return r0
}

// MockInjector_ID_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ID'
type MockInjector_ID_Call struct {
	*mock.Call
}

// ID is a helper method to define mock.On call
func (_e *MockInjector_Expecter) ID() *MockInjector_ID_Call {
	return &MockInjector_ID_Call{Call: _e.mock.On("ID")}
}

func (_c *MockInjector_ID_Call) Run(run func()) *MockInjector_ID_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *MockInjector_ID_Call) Return(s string) *MockInjector_ID_Call {
	_c.Call.Return(s)
	return _c
}

func (_c *MockInjector_ID_Call) RunAndReturn(run func() string) *MockInjector_ID_Call {
	_c.Call.Return(run)
	return _c
}

// ListInvokedServices provides a mock function for the type MockInjector
func (_mock *MockInjector) ListInvokedServices() []do.ServiceDescription {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for ListInvokedServices")
	}

	var r0 []do.ServiceDescription
	if returnFunc, ok := ret.Get(0).(func() []do.ServiceDescription); ok {
		r0 = returnFunc()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]do.ServiceDescription)
		}
	}
	return r0
}

// MockInjector_ListInvokedServices_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListInvokedServices'
type MockInjector_ListInvokedServices_Call struct {
	*mock.Call
}

// ListInvokedServices is a helper method to define mock.On call
func (_e *MockInjector_Expecter) ListInvokedServices() *MockInjector_ListInvokedServices_Call {
	return &MockInjector_ListInvokedServices_Call{Call: _e.mock.On("ListInvokedServices")}
}

func (_c *MockInjector_ListInvokedServices_Call) Run(run func()) *MockInjector_ListInvokedServices_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *MockInjector_ListInvokedServices_Call) Return(serviceDescriptions []do.ServiceDescription) *MockInjector_ListInvokedServices_Call {
	_c.Call.Return(serviceDescriptions)
	return _c
}

func (_c *MockInjector_ListInvokedServices_Call) RunAndReturn(run func() []do.ServiceDescription) *MockInjector_ListInvokedServices_Call {
	_c.Call.Return(run)
	return _c
}

// ListProvidedServices provides a mock function for the type MockInjector
func (_mock *MockInjector) ListProvidedServices() []do.ServiceDescription {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for ListProvidedServices")
	}

	var r0 []do.ServiceDescription
	if returnFunc, ok := ret.Get(0).(func() []do.ServiceDescription); ok {
		r0 = returnFunc()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]do.ServiceDescription)
		}
	}
	return r0
}

// MockInjector_ListProvidedServices_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListProvidedServices'
type MockInjector_ListProvidedServices_Call struct {
	*mock.Call
}

// ListProvidedServices is a helper method to define mock.On call
func (_e *MockInjector_Expecter) ListProvidedServices() *MockInjector_ListProvidedServices_Call {
	return &MockInjector_ListProvidedServices_Call{Call: _e.mock.On("ListProvidedServices")}
}

func (_c *MockInjector_ListProvidedServices_Call) Run(run func()) *MockInjector_ListProvidedServices_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *MockInjector_ListProvidedServices_Call) Return(serviceDescriptions []do.ServiceDescription) *MockInjector_ListProvidedServices_Call {
	_c.Call.Return(serviceDescriptions)
	return _c
}

func (_c *MockInjector_ListProvidedServices_Call) RunAndReturn(run func() []do.ServiceDescription) *MockInjector_ListProvidedServices_Call {
	_c.Call.Return(run)
	return _c
}

// Name provides a mock function for the type MockInjector
func (_mock *MockInjector) Name() string {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for Name")
	}

	var r0 string
	if returnFunc, ok := ret.Get(0).(func() string); ok {
		r0 = returnFunc()
	} else {
		r0 = ret.Get(0).(string)
	}
	return r0
}

// MockInjector_Name_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Name'
type MockInjector_Name_Call struct {
	*mock.Call
}

// Name is a helper method to define mock.On call
func (_e *MockInjector_Expecter) Name() *MockInjector_Name_Call {
	return &MockInjector_Name_Call{Call: _e.mock.On("Name")}
}

func (_c *MockInjector_Name_Call) Run(run func()) *MockInjector_Name_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *MockInjector_Name_Call) Return(s string) *MockInjector_Name_Call {
	_c.Call.Return(s)
	return _c
}

func (_c *MockInjector_Name_Call) RunAndReturn(run func() string) *MockInjector_Name_Call {
	_c.Call.Return(run)
	return _c
}

// RootScope provides a mock function for the type MockInjector
func (_mock *MockInjector) RootScope() *do.RootScope {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for RootScope")
	}

	var r0 *do.RootScope
	if returnFunc, ok := ret.Get(0).(func() *do.RootScope); ok {
		r0 = returnFunc()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*do.RootScope)
		}
	}
	return r0
}

// MockInjector_RootScope_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RootScope'
type MockInjector_RootScope_Call struct {
	*mock.Call
}

// RootScope is a helper method to define mock.On call
func (_e *MockInjector_Expecter) RootScope() *MockInjector_RootScope_Call {
	return &MockInjector_RootScope_Call{Call: _e.mock.On("RootScope")}
}

func (_c *MockInjector_RootScope_Call) Run(run func()) *MockInjector_RootScope_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *MockInjector_RootScope_Call) Return(rootScope *do.RootScope) *MockInjector_RootScope_Call {
	_c.Call.Return(rootScope)
	return _c
}

func (_c *MockInjector_RootScope_Call) RunAndReturn(run func() *do.RootScope) *MockInjector_RootScope_Call {
	_c.Call.Return(run)
	return _c
}

// Scope provides a mock function for the type MockInjector
func (_mock *MockInjector) Scope(s string, fns ...func(do.Injector)) *do.Scope {
	var tmpRet mock.Arguments
	if len(fns) > 0 {
		tmpRet = _mock.Called(s, fns)
	} else {
		tmpRet = _mock.Called(s)
	}
	ret := tmpRet

	if len(ret) == 0 {
		panic("no return value specified for Scope")
	}

	var r0 *do.Scope
	if returnFunc, ok := ret.Get(0).(func(string, ...func(do.Injector)) *do.Scope); ok {
		r0 = returnFunc(s, fns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*do.Scope)
		}
	}
	return r0
}

// MockInjector_Scope_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Scope'
type MockInjector_Scope_Call struct {
	*mock.Call
}

// Scope is a helper method to define mock.On call
//   - s string
//   - fns ...func(do.Injector)
func (_e *MockInjector_Expecter) Scope(s interface{}, fns ...interface{}) *MockInjector_Scope_Call {
	return &MockInjector_Scope_Call{Call: _e.mock.On("Scope",
		append([]interface{}{s}, fns...)...)}
}

func (_c *MockInjector_Scope_Call) Run(run func(s string, fns ...func(do.Injector))) *MockInjector_Scope_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 string
		if args[0] != nil {
			arg0 = args[0].(string)
		}
		var arg1 []func(do.Injector)
		var variadicArgs []func(do.Injector)
		if len(args) > 1 {
			variadicArgs = args[1].([]func(do.Injector))
		}
		arg1 = variadicArgs
		run(
			arg0,
			arg1...,
		)
	})
	return _c
}

func (_c *MockInjector_Scope_Call) Return(scope *do.Scope) *MockInjector_Scope_Call {
	_c.Call.Return(scope)
	return _c
}

func (_c *MockInjector_Scope_Call) RunAndReturn(run func(s string, fns ...func(do.Injector)) *do.Scope) *MockInjector_Scope_Call {
	_c.Call.Return(run)
	return _c
}

// Shutdown provides a mock function for the type MockInjector
func (_mock *MockInjector) Shutdown() *do.ShutdownReport {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for Shutdown")
	}

	var r0 *do.ShutdownReport
	if returnFunc, ok := ret.Get(0).(func() *do.ShutdownReport); ok {
		r0 = returnFunc()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*do.ShutdownReport)
		}
	}
	return r0
}

// MockInjector_Shutdown_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Shutdown'
type MockInjector_Shutdown_Call struct {
	*mock.Call
}

// Shutdown is a helper method to define mock.On call
func (_e *MockInjector_Expecter) Shutdown() *MockInjector_Shutdown_Call {
	return &MockInjector_Shutdown_Call{Call: _e.mock.On("Shutdown")}
}

func (_c *MockInjector_Shutdown_Call) Run(run func()) *MockInjector_Shutdown_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *MockInjector_Shutdown_Call) Return(shutdownReport *do.ShutdownReport) *MockInjector_Shutdown_Call {
	_c.Call.Return(shutdownReport)
	return _c
}

func (_c *MockInjector_Shutdown_Call) RunAndReturn(run func() *do.ShutdownReport) *MockInjector_Shutdown_Call {
	_c.Call.Return(run)
	return _c
}

// ShutdownWithContext provides a mock function for the type MockInjector
func (_mock *MockInjector) ShutdownWithContext(context1 context.Context) *do.ShutdownReport {
	ret := _mock.Called(context1)

	if len(ret) == 0 {
		panic("no return value specified for ShutdownWithContext")
	}

	var r0 *do.ShutdownReport
	if returnFunc, ok := ret.Get(0).(func(context.Context) *do.ShutdownReport); ok {
		r0 = returnFunc(context1)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*do.ShutdownReport)
		}
	}
	return r0
}

// MockInjector_ShutdownWithContext_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ShutdownWithContext'
type MockInjector_ShutdownWithContext_Call struct {
	*mock.Call
}

// ShutdownWithContext is a helper method to define mock.On call
//   - context1 context.Context
func (_e *MockInjector_Expecter) ShutdownWithContext(context1 interface{}) *MockInjector_ShutdownWithContext_Call {
	return &MockInjector_ShutdownWithContext_Call{Call: _e.mock.On("ShutdownWithContext", context1)}
}

func (_c *MockInjector_ShutdownWithContext_Call) Run(run func(context1 context.Context)) *MockInjector_ShutdownWithContext_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *MockInjector_ShutdownWithContext_Call) Return(shutdownReport *do.ShutdownReport) *MockInjector_ShutdownWithContext_Call {
	_c.Call.Return(shutdownReport)
	return _c
}

func (_c *MockInjector_ShutdownWithContext_Call) RunAndReturn(run func(context1 context.Context) *do.ShutdownReport) *MockInjector_ShutdownWithContext_Call {
	_c.Call.Return(run)
	return _c
}

// clone provides a mock function for the type MockInjector
func (_mock *MockInjector) clone(rootScope *do.RootScope, scope *do.Scope) *do.Scope {
	ret := _mock.Called(rootScope, scope)

	if len(ret) == 0 {
		panic("no return value specified for clone")
	}

	var r0 *do.Scope
	if returnFunc, ok := ret.Get(0).(func(*do.RootScope, *do.Scope) *do.Scope); ok {
		r0 = returnFunc(rootScope, scope)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*do.Scope)
		}
	}
	return r0
}

// MockInjector_clone_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'clone'
type MockInjector_clone_Call struct {
	*mock.Call
}

// clone is a helper method to define mock.On call
//   - rootScope *do.RootScope
//   - scope *do.Scope
func (_e *MockInjector_Expecter) clone(rootScope interface{}, scope interface{}) *MockInjector_clone_Call {
	return &MockInjector_clone_Call{Call: _e.mock.On("clone", rootScope, scope)}
}

func (_c *MockInjector_clone_Call) Run(run func(rootScope *do.RootScope, scope *do.Scope)) *MockInjector_clone_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 *do.RootScope
		if args[0] != nil {
			arg0 = args[0].(*do.RootScope)
		}
		var arg1 *do.Scope
		if args[1] != nil {
			arg1 = args[1].(*do.Scope)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockInjector_clone_Call) Return(scope1 *do.Scope) *MockInjector_clone_Call {
	_c.Call.Return(scope1)
	return _c
}

func (_c *MockInjector_clone_Call) RunAndReturn(run func(rootScope *do.RootScope, scope *do.Scope) *do.Scope) *MockInjector_clone_Call {
	_c.Call.Return(run)
	return _c
}

// onServiceInvoke provides a mock function for the type MockInjector
func (_mock *MockInjector) onServiceInvoke(s string) {
	_mock.Called(s)
	return
}

// MockInjector_onServiceInvoke_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'onServiceInvoke'
type MockInjector_onServiceInvoke_Call struct {
	*mock.Call
}

// onServiceInvoke is a helper method to define mock.On call
//   - s string
func (_e *MockInjector_Expecter) onServiceInvoke(s interface{}) *MockInjector_onServiceInvoke_Call {
	return &MockInjector_onServiceInvoke_Call{Call: _e.mock.On("onServiceInvoke", s)}
}

func (_c *MockInjector_onServiceInvoke_Call) Run(run func(s string)) *MockInjector_onServiceInvoke_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 string
		if args[0] != nil {
			arg0 = args[0].(string)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *MockInjector_onServiceInvoke_Call) Return() *MockInjector_onServiceInvoke_Call {
	_c.Call.Return()
	return _c
}

func (_c *MockInjector_onServiceInvoke_Call) RunAndReturn(run func(s string)) *MockInjector_onServiceInvoke_Call {
	_c.Run(run)
	return _c
}

// serviceExist provides a mock function for the type MockInjector
func (_mock *MockInjector) serviceExist(s string) bool {
	ret := _mock.Called(s)

	if len(ret) == 0 {
		panic("no return value specified for serviceExist")
	}

	var r0 bool
	if returnFunc, ok := ret.Get(0).(func(string) bool); ok {
		r0 = returnFunc(s)
	} else {
		r0 = ret.Get(0).(bool)
	}
	return r0
}

// MockInjector_serviceExist_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'serviceExist'
type MockInjector_serviceExist_Call struct {
	*mock.Call
}

// serviceExist is a helper method to define mock.On call
//   - s string
func (_e *MockInjector_Expecter) serviceExist(s interface{}) *MockInjector_serviceExist_Call {
	return &MockInjector_serviceExist_Call{Call: _e.mock.On("serviceExist", s)}
}

func (_c *MockInjector_serviceExist_Call) Run(run func(s string)) *MockInjector_serviceExist_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 string
		if args[0] != nil {
			arg0 = args[0].(string)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *MockInjector_serviceExist_Call) Return(b bool) *MockInjector_serviceExist_Call {
	_c.Call.Return(b)
	return _c
}

func (_c *MockInjector_serviceExist_Call) RunAndReturn(run func(s string) bool) *MockInjector_serviceExist_Call {
	_c.Call.Return(run)
	return _c
}

// serviceExistRec provides a mock function for the type MockInjector
func (_mock *MockInjector) serviceExistRec(s string) bool {
	ret := _mock.Called(s)

	if len(ret) == 0 {
		panic("no return value specified for serviceExistRec")
	}

	var r0 bool
	if returnFunc, ok := ret.Get(0).(func(string) bool); ok {
		r0 = returnFunc(s)
	} else {
		r0 = ret.Get(0).(bool)
	}
	return r0
}

// MockInjector_serviceExistRec_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'serviceExistRec'
type MockInjector_serviceExistRec_Call struct {
	*mock.Call
}

// serviceExistRec is a helper method to define mock.On call
//   - s string
func (_e *MockInjector_Expecter) serviceExistRec(s interface{}) *MockInjector_serviceExistRec_Call {
	return &MockInjector_serviceExistRec_Call{Call: _e.mock.On("serviceExistRec", s)}
}

func (_c *MockInjector_serviceExistRec_Call) Run(run func(s string)) *MockInjector_serviceExistRec_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 string
		if args[0] != nil {
			arg0 = args[0].(string)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *MockInjector_serviceExistRec_Call) Return(b bool) *MockInjector_serviceExistRec_Call {
	_c.Call.Return(b)
	return _c
}

func (_c *MockInjector_serviceExistRec_Call) RunAndReturn(run func(s string) bool) *MockInjector_serviceExistRec_Call {
	_c.Call.Return(run)
	return _c
}

// serviceForEach provides a mock function for the type MockInjector
func (_mock *MockInjector) serviceForEach(fn func(string, *do.Scope, any) bool) {
	_mock.Called(fn)
	return
}

// MockInjector_serviceForEach_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'serviceForEach'
type MockInjector_serviceForEach_Call struct {
	*mock.Call
}

// serviceForEach is a helper method to define mock.On call
//   - fn func(string, *do.Scope, any) bool
func (_e *MockInjector_Expecter) serviceForEach(fn interface{}) *MockInjector_serviceForEach_Call {
	return &MockInjector_serviceForEach_Call{Call: _e.mock.On("serviceForEach", fn)}
}

func (_c *MockInjector_serviceForEach_Call) Run(run func(fn func(string, *do.Scope, any) bool)) *MockInjector_serviceForEach_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 func(string, *do.Scope, any) bool
		if args[0] != nil {
			arg0 = args[0].(func(string, *do.Scope, any) bool)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *MockInjector_serviceForEach_Call) Return() *MockInjector_serviceForEach_Call {
	_c.Call.Return()
	return _c
}

func (_c *MockInjector_serviceForEach_Call) RunAndReturn(run func(fn func(string, *do.Scope, any) bool)) *MockInjector_serviceForEach_Call {
	_c.Run(run)
	return _c
}

// serviceForEachRec provides a mock function for the type MockInjector
func (_mock *MockInjector) serviceForEachRec(fn func(string, *do.Scope, any) bool) {
	_mock.Called(fn)
	return
}

// MockInjector_serviceForEachRec_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'serviceForEachRec'
type MockInjector_serviceForEachRec_Call struct {
	*mock.Call
}

// serviceForEachRec is a helper method to define mock.On call
//   - fn func(string, *do.Scope, any) bool
func (_e *MockInjector_Expecter) serviceForEachRec(fn interface{}) *MockInjector_serviceForEachRec_Call {
	return &MockInjector_serviceForEachRec_Call{Call: _e.mock.On("serviceForEachRec", fn)}
}

func (_c *MockInjector_serviceForEachRec_Call) Run(run func(fn func(string, *do.Scope, any) bool)) *MockInjector_serviceForEachRec_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 func(string, *do.Scope, any) bool
		if args[0] != nil {
			arg0 = args[0].(func(string, *do.Scope, any) bool)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *MockInjector_serviceForEachRec_Call) Return() *MockInjector_serviceForEachRec_Call {
	_c.Call.Return()
	return _c
}

func (_c *MockInjector_serviceForEachRec_Call) RunAndReturn(run func(fn func(string, *do.Scope, any) bool)) *MockInjector_serviceForEachRec_Call {
	_c.Run(run)
	return _c
}

// serviceGet provides a mock function for the type MockInjector
func (_mock *MockInjector) serviceGet(s string) (any, bool) {
	ret := _mock.Called(s)

	if len(ret) == 0 {
		panic("no return value specified for serviceGet")
	}

	var r0 any
	var r1 bool
	if returnFunc, ok := ret.Get(0).(func(string) (any, bool)); ok {
		return returnFunc(s)
	}
	if returnFunc, ok := ret.Get(0).(func(string) any); ok {
		r0 = returnFunc(s)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(any)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(string) bool); ok {
		r1 = returnFunc(s)
	} else {
		r1 = ret.Get(1).(bool)
	}
	return r0, r1
}

// MockInjector_serviceGet_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'serviceGet'
type MockInjector_serviceGet_Call struct {
	*mock.Call
}

// serviceGet is a helper method to define mock.On call
//   - s string
func (_e *MockInjector_Expecter) serviceGet(s interface{}) *MockInjector_serviceGet_Call {
	return &MockInjector_serviceGet_Call{Call: _e.mock.On("serviceGet", s)}
}

func (_c *MockInjector_serviceGet_Call) Run(run func(s string)) *MockInjector_serviceGet_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 string
		if args[0] != nil {
			arg0 = args[0].(string)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *MockInjector_serviceGet_Call) Return(v any, b bool) *MockInjector_serviceGet_Call {
	_c.Call.Return(v, b)
	return _c
}

func (_c *MockInjector_serviceGet_Call) RunAndReturn(run func(s string) (any, bool)) *MockInjector_serviceGet_Call {
	_c.Call.Return(run)
	return _c
}

// serviceGetRec provides a mock function for the type MockInjector
func (_mock *MockInjector) serviceGetRec(s string) (any, *do.Scope, bool) {
	ret := _mock.Called(s)

	if len(ret) == 0 {
		panic("no return value specified for serviceGetRec")
	}

	var r0 any
	var r1 *do.Scope
	var r2 bool
	if returnFunc, ok := ret.Get(0).(func(string) (any, *do.Scope, bool)); ok {
		return returnFunc(s)
	}
	if returnFunc, ok := ret.Get(0).(func(string) any); ok {
		r0 = returnFunc(s)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(any)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(string) *do.Scope); ok {
		r1 = returnFunc(s)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*do.Scope)
		}
	}
	if returnFunc, ok := ret.Get(2).(func(string) bool); ok {
		r2 = returnFunc(s)
	} else {
		r2 = ret.Get(2).(bool)
	}
	return r0, r1, r2
}

// MockInjector_serviceGetRec_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'serviceGetRec'
type MockInjector_serviceGetRec_Call struct {
	*mock.Call
}

// serviceGetRec is a helper method to define mock.On call
//   - s string
func (_e *MockInjector_Expecter) serviceGetRec(s interface{}) *MockInjector_serviceGetRec_Call {
	return &MockInjector_serviceGetRec_Call{Call: _e.mock.On("serviceGetRec", s)}
}

func (_c *MockInjector_serviceGetRec_Call) Run(run func(s string)) *MockInjector_serviceGetRec_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 string
		if args[0] != nil {
			arg0 = args[0].(string)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *MockInjector_serviceGetRec_Call) Return(v any, scope *do.Scope, b bool) *MockInjector_serviceGetRec_Call {
	_c.Call.Return(v, scope, b)
	return _c
}

func (_c *MockInjector_serviceGetRec_Call) RunAndReturn(run func(s string) (any, *do.Scope, bool)) *MockInjector_serviceGetRec_Call {
	_c.Call.Return(run)
	return _c
}

// serviceHealthCheck provides a mock function for the type MockInjector
func (_mock *MockInjector) serviceHealthCheck(context1 context.Context, s string) error {
	ret := _mock.Called(context1, s)

	if len(ret) == 0 {
		panic("no return value specified for serviceHealthCheck")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) error); ok {
		r0 = returnFunc(context1, s)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockInjector_serviceHealthCheck_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'serviceHealthCheck'
type MockInjector_serviceHealthCheck_Call struct {
	*mock.Call
}

// serviceHealthCheck is a helper method to define mock.On call
//   - context1 context.Context
//   - s string
func (_e *MockInjector_Expecter) serviceHealthCheck(context1 interface{}, s interface{}) *MockInjector_serviceHealthCheck_Call {
	return &MockInjector_serviceHealthCheck_Call{Call: _e.mock.On("serviceHealthCheck", context1, s)}
}

func (_c *MockInjector_serviceHealthCheck_Call) Run(run func(context1 context.Context, s string)) *MockInjector_serviceHealthCheck_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockInjector_serviceHealthCheck_Call) Return(err error) *MockInjector_serviceHealthCheck_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockInjector_serviceHealthCheck_Call) RunAndReturn(run func(context1 context.Context, s string) error) *MockInjector_serviceHealthCheck_Call {
	_c.Call.Return(run)
	return _c
}

// serviceSet provides a mock function for the type MockInjector
func (_mock *MockInjector) serviceSet(s string, v any) {
	_mock.Called(s, v)
	return
}

// MockInjector_serviceSet_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'serviceSet'
type MockInjector_serviceSet_Call struct {
	*mock.Call
}

// serviceSet is a helper method to define mock.On call
//   - s string
//   - v any
func (_e *MockInjector_Expecter) serviceSet(s interface{}, v interface{}) *MockInjector_serviceSet_Call {
	return &MockInjector_serviceSet_Call{Call: _e.mock.On("serviceSet", s, v)}
}

func (_c *MockInjector_serviceSet_Call) Run(run func(s string, v any)) *MockInjector_serviceSet_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 string
		if args[0] != nil {
			arg0 = args[0].(string)
		}
		var arg1 any
		if args[1] != nil {
			arg1 = args[1].(any)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockInjector_serviceSet_Call) Return() *MockInjector_serviceSet_Call {
	_c.Call.Return()
	return _c
}

func (_c *MockInjector_serviceSet_Call) RunAndReturn(run func(s string, v any)) *MockInjector_serviceSet_Call {
	_c.Run(run)
	return _c
}

// serviceShutdown provides a mock function for the type MockInjector
func (_mock *MockInjector) serviceShutdown(context1 context.Context, s string) error {
	ret := _mock.Called(context1, s)

	if len(ret) == 0 {
		panic("no return value specified for serviceShutdown")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) error); ok {
		r0 = returnFunc(context1, s)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockInjector_serviceShutdown_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'serviceShutdown'
type MockInjector_serviceShutdown_Call struct {
	*mock.Call
}

// serviceShutdown is a helper method to define mock.On call
//   - context1 context.Context
//   - s string
func (_e *MockInjector_Expecter) serviceShutdown(context1 interface{}, s interface{}) *MockInjector_serviceShutdown_Call {
	return &MockInjector_serviceShutdown_Call{Call: _e.mock.On("serviceShutdown", context1, s)}
}

func (_c *MockInjector_serviceShutdown_Call) Run(run func(context1 context.Context, s string)) *MockInjector_serviceShutdown_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockInjector_serviceShutdown_Call) Return(err error) *MockInjector_serviceShutdown_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockInjector_serviceShutdown_Call) RunAndReturn(run func(context1 context.Context, s string) error) *MockInjector_serviceShutdown_Call {
	_c.Call.Return(run)
	return _c
}
