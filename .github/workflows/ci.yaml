name: CI - Go (Repo)

on:
  push:
    branches: [main]
  pull_request:

permissions: {}

jobs:
  pre-commit:
    runs-on: ubuntu-latest
    permissions:
      contents: write
    steps:
      - name: 📄 Checkout
        uses: actions/checkout@08c6903cd8c0fde910a37f88322edcfb5dd907a8 # v5.0.0
        with:
          persist-credentials: false
          fetch-depth: 0

      - name: ⚙️ Setup Go
        uses: actions/setup-go@44694675825211faa026b3c33043df3e48a5fa00 # v6.0.0
        with:
          go-version-file: go.mod
          cache: true

      - name: 📦 Download dependencies
        run: go mod download

      - name: 🔧 Install mockery
        run: go install github.com/vektra/mockery/v3@latest

      - name: 🏃 Run pre-commit hooks
        uses: pre-commit/action@2c7b3805fd2a0fd8c1884dcaebf91fc102a13ecd # v3.0.1

  ci:
    needs: [pre-commit]
    if: github.event_name == 'push'
    uses: devantler-tech/reusable-workflows/.github/workflows/ci-go.yaml@800bac1f7de14fcc6b9b9bcf62e201308eafd15b # v1.15.12
    secrets:
      CODECOV_TOKEN: ${{ secrets.CODECOV_TOKEN }}
    permissions:
      contents: write
      issues: write
      packages: read
      pull-requests: write

  system-test-lifecycle:
    runs-on: ubuntu-latest
    # Run system tests on both push and pull request, but only after pre-commit and ci jobs complete
    needs: [pre-commit, ci]
    if: always() && (needs.ci.result == 'success' || needs.ci.result == 'skipped')
    strategy:
      matrix:
        include:
          - distribution: Kind
            cni: Default
            init-args: "--distribution Kind"
          - distribution: Kind
            cni: Cilium
            init-args: "--distribution Kind --cni Cilium"
          - distribution: Kind
            cni: Default
            init-args: "--distribution Kind --mirror-registry docker.io=https://registry-1.docker.io"
            mirror-registry: true
          - distribution: K3d
            cni: Default
            init-args: "--distribution K3d"
          - distribution: K3d
            cni: Cilium
            init-args: "--distribution K3d --cni Cilium"
          - distribution: K3d
            cni: Default
            init-args: "--distribution K3d --mirror-registry docker.io=https://registry-1.docker.io"
            mirror-registry: true
    steps:
      - name: 📄 Checkout
        uses: actions/checkout@08c6903cd8c0fde910a37f88322edcfb5dd907a8 # v5.0.0
        with:
          persist-credentials: false

      - name: ⚙️ Setup Go
        uses: actions/setup-go@44694675825211faa026b3c33043df3e48a5fa00 # v6.0.0
        with:
          go-version-file: go.mod
          cache: true

      - name: 📦 Download dependencies
        run: go mod download

      - name: 🏗️ Build application
        run: go build -o ksail .

      - name: 🧪 ksail init (${{ matrix.distribution }} + ${{ matrix.cni }})
        run: |
          ./ksail init ${{ matrix.init-args }}

      - name: 🧪 ksail cluster create
        run: |
          ./ksail cluster create

      - name: 🧪 ksail cluster list
        run: |
          ./ksail cluster list

      - name: 🧪 ksail cluster start
        run: |
          ./ksail cluster start

      - name: 🧪 ksail cluster stop
        run: |
          ./ksail cluster stop

      - name: 🧪 ksail workload reconcile
        run: |
          ./ksail workload reconcile

      - name: 🧪 ksail cluster delete
        run: |
          ./ksail cluster delete

      - name: 🧹 Cleanup
        run: |
          if [ -d "k8s" ]; then rm -rf "k8s"; fi
          if [ -f "kind.yaml" ]; then rm "kind.yaml"; fi
          if [ -f "k3d.yaml" ]; then rm "k3d.yaml"; fi
          if [ -f "ksail.yaml" ]; then rm "ksail.yaml"; fi

  system-test-mirror-registries:
    runs-on: ubuntu-latest
    needs: [pre-commit, ci]
    if: always() && (needs.ci.result == 'success' || needs.ci.result == 'skipped')
    strategy:
      matrix:
        include:
          # Single mirror with single cluster (Kind)
          - name: "1-mirror-1-kind"
            distribution: Kind
            cluster-count: 1
            init-args: "--distribution Kind --mirror-registry docker.io=https://registry-1.docker.io"
          # Single mirror with single cluster (K3d)
          - name: "1-mirror-1-k3d"
            distribution: K3d
            cluster-count: 1
            init-args: "--distribution K3d --mirror-registry docker.io=https://registry-1.docker.io"
          # Single mirror with two Kind clusters
          - name: "1-mirror-2-kind"
            distribution: Kind
            cluster-count: 2
            init-args: "--distribution Kind --mirror-registry docker.io=https://registry-1.docker.io"
          # Single mirror with two K3d clusters
          - name: "1-mirror-2-k3d"
            distribution: K3d
            cluster-count: 2
            init-args: "--distribution K3d --mirror-registry docker.io=https://registry-1.docker.io"
          # Single mirror with mixed clusters (1 Kind + 1 K3d)
          - name: "1-mirror-1-kind-1-k3d"
            distribution: Mixed
            cluster-count: 2
            init-args: "--mirror-registry docker.io=https://registry-1.docker.io"
          # Two mirrors with single Kind cluster
          - name: "2-mirrors-1-kind"
            distribution: Kind
            cluster-count: 1
            init-args: "--distribution Kind --mirror-registry docker.io=https://registry-1.docker.io --mirror-registry quay.io=https://quay.io"
          # Two mirrors with single K3d cluster
          - name: "2-mirrors-1-k3d"
            distribution: K3d
            cluster-count: 1
            init-args: "--distribution K3d --mirror-registry docker.io=https://registry-1.docker.io --mirror-registry quay.io=https://quay.io"
          # Two mirrors with mixed clusters (1 Kind + 1 K3d)
          - name: "2-mirrors-1-kind-1-k3d"
            distribution: Mixed
            cluster-count: 2
            init-args: "--mirror-registry docker.io=https://registry-1.docker.io --mirror-registry quay.io=https://quay.io"
    steps:
      - name: 📄 Checkout
        uses: actions/checkout@08c6903cd8c0fde910a37f88322edcfb5dd907a8 # v5.0.0
        with:
          persist-credentials: false

      - name: ⚙️ Setup Go
        uses: actions/setup-go@44694675825211faa026b3c33043df3e48a5fa00 # v6.0.0
        with:
          go-version-file: go.mod
          cache: true

      - name: 📦 Download dependencies
        run: go mod download

      - name: 🏗️ Build application
        run: go build -o ksail .

      - name: 🧪 Create clusters (${{ matrix.name }})
        run: |
          set -e
          
          if [ "${{ matrix.distribution }}" = "Mixed" ]; then
            # Create one Kind cluster and one K3d cluster
            echo "Creating Kind cluster..."
            mkdir -p test-cluster1
            cd test-cluster1
            cluster_name="${{ matrix.name }}-cluster1"
            ../ksail init --distribution Kind --name "$cluster_name" ${{ matrix.init-args }}
            ../ksail cluster create
            cd ..
            
            echo "Creating K3d cluster..."
            mkdir -p test-cluster2
            cd test-cluster2
            cluster_name="${{ matrix.name }}-cluster2"
            ../ksail init --distribution K3d --name "$cluster_name" ${{ matrix.init-args }}
            ../ksail cluster create
            cd ..
          else
            # Create clusters of the same distribution
            for i in $(seq 1 ${{ matrix.cluster-count }}); do
              echo "Creating ${{ matrix.distribution }} cluster $i..."
              cluster_name="${{ matrix.name }}-cluster$i"
              cluster_dir="test-$cluster_name"
              mkdir -p "$cluster_dir"
              cd "$cluster_dir"
              ../ksail init --name "$cluster_name" ${{ matrix.init-args }}
              ../ksail cluster create
              cd ..
            done
          fi

      - name: 🧪 Test pull-through (${{ matrix.name }})
        run: |
          set -e
          
          # Check that registry containers exist and are running
          echo "Checking registry containers..."
          docker ps --filter "label=io.ksail.registry" --format "table {{.Names}}\t{{.Status}}\t{{.Ports}}"
          
          # Count running registries
          registry_count=$(docker ps --filter "label=io.ksail.registry" --format "{{.Names}}" | wc -l)
          echo "Found $registry_count registry container(s)"
          
          if [ "$registry_count" -eq 0 ]; then
            echo "ERROR: No registry containers found"
            exit 1
          fi
          
          # Use a unique image tag to force fresh pulls (not cached)
          # busybox is smaller and faster to pull than nginx
          TEST_IMAGE="busybox:1.36.1"
          echo "Using test image: $TEST_IMAGE"
          
          # For each cluster, test that it can pull through the mirror
          if [ "${{ matrix.distribution }}" = "Mixed" ]; then
            # Test Kind cluster
            cluster_name="${{ matrix.name }}-cluster1"
            context="kind-$cluster_name"
            echo "Testing pull-through for Kind cluster: $context..."
            
            # Wait for nodes to be ready before creating pods
            echo "Waiting for nodes to be ready..."
            kubectl --context="$context" wait --for=condition=Ready nodes --all --timeout=60s
            
            # Wait for default service account to be created (more stable)
            echo "Waiting for default service account..."
            for i in {1..30}; do
              if kubectl --context="$context" get serviceaccount default -n default &>/dev/null; then
                echo "✓ Default service account exists"
                break
              fi
              if [ $i -eq 30 ]; then
                echo "ERROR: Default service account not found after 30 seconds"
                kubectl --context="$context" get serviceaccounts -n default
                exit 1
              fi
              sleep 1
            done
            
            kubectl --context="$context" run test-busybox-cluster1 \
              --image="$TEST_IMAGE" \
              --restart=Never \
              --command -- sh -c "sleep 30"
            
            # Wait for pod to be ready (with timeout)
            echo "Waiting for pod to be ready..."
            kubectl --context="$context" wait --for=condition=Ready pod/test-busybox-cluster1 --timeout=120s
            
            # Verify pod status
            pod_status=$(kubectl --context="$context" get pod test-busybox-cluster1 -o jsonpath='{.status.phase}')
            if [ "$pod_status" != "Running" ]; then
              echo "ERROR: Pod failed to start. Status: $pod_status"
              kubectl --context="$context" describe pod test-busybox-cluster1
              exit 1
            fi
            echo "✓ Pod test-busybox-cluster1 is running"
            
            # Show pod events to see image pull activity
            echo "Pod events:"
            kubectl --context="$context" get events --field-selector involvedObject.name=test-busybox-cluster1 --sort-by='.lastTimestamp'
            
            # Clean up test pod
            kubectl --context="$context" delete pod test-busybox-cluster1
            
            # Test K3d cluster
            cluster_name="${{ matrix.name }}-cluster2"
            context="k3d-$cluster_name"
            echo "Testing pull-through for K3d cluster: $context..."
            
            # Wait for nodes to be ready before creating pods
            echo "Waiting for nodes to be ready..."
            kubectl --context="$context" wait --for=condition=Ready nodes --all --timeout=60s
            
            # Wait for default service account to be created (more stable)
            echo "Waiting for default service account..."
            for i in {1..30}; do
              if kubectl --context="$context" get serviceaccount default -n default &>/dev/null; then
                echo "✓ Default service account exists"
                break
              fi
              if [ $i -eq 30 ]; then
                echo "ERROR: Default service account not found after 30 seconds"
                kubectl --context="$context" get serviceaccounts -n default
                exit 1
              fi
              sleep 1
            done
            
            kubectl --context="$context" run test-busybox-cluster2 \
              --image="$TEST_IMAGE" \
              --restart=Never \
              --command -- sh -c "sleep 30"
            
            # Wait for pod to be ready (with timeout)
            echo "Waiting for pod to be ready..."
            kubectl --context="$context" wait --for=condition=Ready pod/test-busybox-cluster2 --timeout=120s
            
            # Verify pod status
            pod_status=$(kubectl --context="$context" get pod test-busybox-cluster2 -o jsonpath='{.status.phase}')
            if [ "$pod_status" != "Running" ]; then
              echo "ERROR: Pod failed to start. Status: $pod_status"
              kubectl --context="$context" describe pod test-busybox-cluster2
              exit 1
            fi
            echo "✓ Pod test-busybox-cluster2 is running"
            
            # Show pod events to see image pull activity
            echo "Pod events:"
            kubectl --context="$context" get events --field-selector involvedObject.name=test-busybox-cluster2 --sort-by='.lastTimestamp'
            
            # Clean up test pod
            kubectl --context="$context" delete pod test-busybox-cluster2
          else
            for i in $(seq 1 ${{ matrix.cluster-count }}); do
              cluster_name="${{ matrix.name }}-cluster$i"
              
              # Set context based on distribution
              if [ "${{ matrix.distribution }}" = "Kind" ]; then
                context="kind-$cluster_name"
              else
                context="k3d-$cluster_name"
              fi
              
              echo "Testing pull-through for $context..."
              
              # Wait for nodes to be ready before creating pods
              echo "Waiting for nodes to be ready..."
              kubectl --context="$context" wait --for=condition=Ready nodes --all --timeout=60s
              
              # Wait for default service account to be created (more stable)
              echo "Waiting for default service account..."
              for j in {1..30}; do
                if kubectl --context="$context" get serviceaccount default -n default &>/dev/null; then
                  echo "✓ Default service account exists"
                  break
                fi
                if [ $j -eq 30 ]; then
                  echo "ERROR: Default service account not found after 30 seconds"
                  kubectl --context="$context" get serviceaccounts -n default
                  exit 1
                fi
                sleep 1
              done
              
              kubectl --context="$context" run "test-busybox-${cluster_name}" \
                --image="$TEST_IMAGE" \
                --restart=Never \
                --command -- sh -c "sleep 30"
              
              # Wait for pod to be ready (with timeout)
              echo "Waiting for pod to be ready..."
              kubectl --context="$context" wait --for=condition=Ready "pod/test-busybox-${cluster_name}" --timeout=120s
              
              # Verify pod status
              pod_status=$(kubectl --context="$context" get pod "test-busybox-${cluster_name}" -o jsonpath='{.status.phase}')
              if [ "$pod_status" != "Running" ]; then
                echo "ERROR: Pod failed to start. Status: $pod_status"
                kubectl --context="$context" describe pod "test-busybox-${cluster_name}"
                exit 1
              fi
              echo "✓ Pod test-busybox-${cluster_name} is running"
              
              # Show pod events to see image pull activity
              echo "Pod events:"
              kubectl --context="$context" get events --field-selector "involvedObject.name=test-busybox-${cluster_name}" --sort-by='.lastTimestamp'
              
              # Clean up test pod
              kubectl --context="$context" delete pod "test-busybox-${cluster_name}"
            done
          fi
          
          # Verify registry logs show pull-through activity
          echo "Verifying pull-through activity in registry logs..."
          echo "Note: Checking for various indicators of image pull activity"
          pull_activity_found=false
          
          for registry in $(docker ps --filter "label=io.ksail.registry" --format "{{.Names}}"); do
            echo "=== Checking logs for $registry ==="
            # Look for GET requests, blob operations, or manifest requests which indicate image pulls
            if docker logs "$registry" 2>&1 | grep -qE "(GET /v2/|/blobs/|/manifests/)"; then
              echo "✓ Pull-through activity detected in $registry"
              echo "Recent registry activity:"
              docker logs "$registry" 2>&1 | grep -E "(GET /v2/|/blobs/|/manifests/)" | tail -20
              pull_activity_found=true
            else
              echo "⚠ No pull-through activity detected in $registry"
            fi
          done
          
          if [ "$pull_activity_found" = false ]; then
            echo ""
            echo "ERROR: No pull-through activity detected in any registry"
            echo "This may indicate:"
            echo "1. Images are cached and not being pulled"
            echo "2. Registry is not configured correctly as a pull-through cache"
            echo "3. Clusters are not configured to use the mirror registries"
            echo ""
            echo "Dumping all registry logs for debugging:"
            for registry in $(docker ps --filter "label=io.ksail.registry" --format "{{.Names}}"); do
              echo "=== Full logs for $registry ==="
              docker logs "$registry" 2>&1 | tail -100
            done
            echo ""
            echo "Cluster configurations:"
            for context in $(kubectl config get-contexts -o name | grep -E "(kind-|k3d-)"); do
              echo "=== Context: $context ==="
              kubectl --context="$context" get nodes -o wide || true
            done
            exit 1
          fi
          
          echo "✓ Pull-through verification successful"

      - name: 🧪 Delete clusters (${{ matrix.name }})
        if: always()
        run: |
          if [ "${{ matrix.distribution }}" = "Mixed" ]; then
            # Delete Kind cluster
            cd test-cluster1
            ../ksail cluster delete || true
            cd ..
            rm -rf test-cluster1
            
            # Delete K3d cluster
            cd test-cluster2
            ../ksail cluster delete || true
            cd ..
            rm -rf test-cluster2
          else
            for i in $(seq 1 ${{ matrix.cluster-count }}); do
              cluster_name="${{ matrix.name }}-cluster$i"
              cluster_dir="test-$cluster_name"
              
              if [ -d "$cluster_dir" ]; then
                cd "$cluster_dir"
                ../ksail cluster delete || true
                cd ..
                rm -rf "$cluster_dir"
              fi
            done
          fi

      - name: 🧹 Cleanup
        if: always()
        run: |
          # Clean up any remaining test directories
          rm -rf test-cluster* || true
          
          # Verify registries were cleaned up appropriately
          echo "Remaining registry containers:"
          docker ps -a --filter "label=io.ksail.registry" --format "table {{.Names}}\t{{.Status}}" || true

  system-test-status:
    runs-on: ubuntu-latest
    needs: [system-test-lifecycle, system-test-mirror-registries]
    if: always()
    steps:
      - name: Summarize matrix result
        shell: bash
        run: |
          set -Eeuo pipefail
          echo "system-test-lifecycle result: $LIFECYCLE_TEST_RESULT"
          echo "system-test-mirror-registries result: $MIRROR_TEST_RESULT"
          
          # Check if both jobs succeeded or were skipped
          if [[ "$LIFECYCLE_TEST_RESULT" =~ ^(success|skipped)$ ]] && [[ "$MIRROR_TEST_RESULT" =~ ^(success|skipped)$ ]]; then
            echo "All system tests succeeded or were skipped."
            exit 0
          else
            echo "At least one system test failed."
            echo "  system-test-lifecycle: $LIFECYCLE_TEST_RESULT"
            echo "  system-test-mirror-registries: $MIRROR_TEST_RESULT"
            exit 1
          fi
        env:
          LIFECYCLE_TEST_RESULT: ${{ needs.system-test-lifecycle.result }}
          MIRROR_TEST_RESULT: ${{ needs.system-test-mirror-registries.result }}
