
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>kubectl: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/devantler-tech/ksail-go/pkg/installer/kubectl/installer.go (76.7%)</option>
				
				<option value="file1">github.com/devantler-tech/ksail-go/pkg/installer/kubectl/interfaces.go (29.4%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">// Package kubectlinstaller provides a kubectl installer implementation.
package kubectlinstaller

import (
        "context"
        _ "embed"
        "errors"
        "fmt"
        "time"

        pathutils "github.com/devantler-tech/ksail-go/internal/utils/path"
        apiextensionsv1 "k8s.io/apiextensions-apiserver/pkg/apis/apiextensions/v1"
        apierrors "k8s.io/apimachinery/pkg/api/errors"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "k8s.io/apimachinery/pkg/apis/meta/v1/unstructured"
        "k8s.io/apimachinery/pkg/runtime/schema"
        "k8s.io/apimachinery/pkg/util/wait"
        "k8s.io/client-go/rest"
        "k8s.io/client-go/tools/clientcmd"
        "k8s.io/client-go/tools/clientcmd/api"
        "sigs.k8s.io/yaml"
)

//go:embed assets/apply-set-crd.yaml
var applySetCRDYAML []byte

//go:embed assets/apply-set-cr.yaml
var applySetCRYAML []byte

// boolPtr returns a pointer to the given boolean value.
func boolPtr(b bool) *bool <span class="cov8" title="1">{
        return &amp;b
}</span>

// createDefaultDeleteOptions creates a metav1.DeleteOptions with all fields explicitly set.
func createDefaultDeleteOptions() metav1.DeleteOptions <span class="cov8" title="1">{
        return metav1.DeleteOptions{
                TypeMeta: metav1.TypeMeta{
                        Kind:       "",
                        APIVersion: "",
                },
                GracePeriodSeconds: nil,
                Preconditions:      nil,
                OrphanDependents:   nil,
                PropagationPolicy:  nil,
                DryRun:             nil,
                IgnoreStoreReadErrorWithClusterBreakingPotential: boolPtr(false),
        }
}</span>

// ErrCRDNameNotAccepted is returned when CRD names are not accepted.
var ErrCRDNameNotAccepted = errors.New("crd names not accepted")

// KubectlInstaller implements the installer.Installer interface for kubectl.
type KubectlInstaller struct {
        kubeconfig    string
        context       string
        timeout       time.Duration
        clientFactory ClientFactoryInterface
}

// NewKubectlInstaller creates a new kubectl installer instance.
func NewKubectlInstaller(kubeconfig, context string, timeout time.Duration) *KubectlInstaller <span class="cov8" title="1">{
        return &amp;KubectlInstaller{
                kubeconfig:    kubeconfig,
                context:       context,
                timeout:       timeout,
                clientFactory: NewDefaultClientFactory(),
        }
}</span>

// NewKubectlInstallerWithFactory creates a new kubectl installer instance with a custom client factory.
func NewKubectlInstallerWithFactory(kubeconfig, context string, timeout time.Duration, clientFactory ClientFactoryInterface) *KubectlInstaller <span class="cov8" title="1">{
        return &amp;KubectlInstaller{
                kubeconfig:    kubeconfig,
                context:       context,
                timeout:       timeout,
                clientFactory: clientFactory,
        }
}</span>

// Install ensures the ApplySet CRD and its parent CR exist.
func (b *KubectlInstaller) Install() error <span class="cov8" title="1">{
        restConfigWrapper, err := b.buildRESTConfig()
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">err = b.installCRD(restConfigWrapper)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">err = b.installApplySetCR(restConfigWrapper)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// Uninstall deletes the ApplySet CR then its CRD.
func (b *KubectlInstaller) Uninstall() error <span class="cov8" title="1">{
        config, err := b.buildRESTConfig()
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">ctx, cancel := context.WithTimeout(context.Background(), b.timeout)
        defer cancel()

        gvr := schema.GroupVersionResource{Group: "k8s.devantler.tech", Version: "v1", Resource: "applysets"}
        
        dynClient, err := b.clientFactory.CreateDynamicClient(config, gvr)
        if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("failed to create dynamic client: %w", err)
        }</span>

        <span class="cov8" title="1">_ = dynClient.Delete(ctx, "ksail", createDefaultDeleteOptions()) // ignore errors (including NotFound)

        apiExtClient, err := b.clientFactory.CreateAPIExtensionsClient(config)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create apiextensions client: %w", err)
        }</span>

        <span class="cov8" title="1">_ = apiExtClient.Delete(ctx, "applysets.k8s.devantler.tech", createDefaultDeleteOptions())

        return nil</span>
}

// --- internals ---

// installCRD installs the ApplySet CRD.
func (b *KubectlInstaller) installCRD(restConfig *rest.Config) error <span class="cov8" title="1">{
        apiExtClient, err := b.clientFactory.CreateAPIExtensionsClient(restConfig)
        if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("failed to create apiextensions client: %w", err)
        }</span>

        <span class="cov8" title="1">ctx, cancel := context.WithTimeout(context.Background(), b.timeout)
        defer cancel()

        const crdName = "applysets.k8s.devantler.tech"

        _, err = apiExtClient.Get(ctx, crdName, metav1.GetOptions{
                TypeMeta: metav1.TypeMeta{
                        Kind:       "",
                        APIVersion: "",
                },
                ResourceVersion: "",
        })
        if apierrors.IsNotFound(err) </span><span class="cov8" title="1">{
                err = b.applyCRD(ctx, apiExtClient)
                if err != nil </span><span class="cov8" title="1">{
                        return err
                }</span>

                <span class="cov8" title="1">err = b.waitForCRDEstablished(ctx, apiExtClient, crdName)
                if err != nil </span><span class="cov8" title="1">{
                        return err
                }</span>
        } else<span class="cov8" title="1"> if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("failed to check CRD existence: %w", err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// installApplySetCR installs the ApplySet custom resource.
func (b *KubectlInstaller) installApplySetCR(restConfig *rest.Config) error <span class="cov8" title="1">{
        gvr := schema.GroupVersionResource{Group: "k8s.devantler.tech", Version: "v1", Resource: "applysets"}
        
        dynClient, err := b.clientFactory.CreateDynamicClient(restConfig, gvr)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create dynamic client: %w", err)
        }</span>

        <span class="cov8" title="1">ctx, cancel := context.WithTimeout(context.Background(), b.timeout)
        defer cancel()

        const applySetName = "ksail"

        _, err = dynClient.Get(ctx, applySetName, metav1.GetOptions{
                TypeMeta: metav1.TypeMeta{
                        Kind:       "",
                        APIVersion: "",
                },
                ResourceVersion: "",
        })
        if apierrors.IsNotFound(err) </span><span class="cov8" title="1">{
                err = b.applyApplySetCR(ctx, dynClient, applySetName)
                if err != nil </span><span class="cov8" title="1">{
                        return err
                }</span>
        } else<span class="cov0" title="0"> if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get ApplySet CR: %w", err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func (b *KubectlInstaller) buildRESTConfig() (*rest.Config, error) <span class="cov8" title="1">{
        kubeconfigPath, _ := pathutils.ExpandHomePath(b.kubeconfig)
        rules := b.buildClientConfigLoadingRules(kubeconfigPath)
        overrides := b.buildConfigOverrides()

        clientCfg := clientcmd.NewNonInteractiveDeferredLoadingClientConfig(rules, overrides)

        restConfig, err := clientCfg.ClientConfig()
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("failed to build rest config: %w", err)
        }</span>

        <span class="cov8" title="1">return restConfig, nil</span>
}

func (b *KubectlInstaller) buildClientConfigLoadingRules(kubeconfigPath string) *clientcmd.ClientConfigLoadingRules <span class="cov8" title="1">{
        return &amp;clientcmd.ClientConfigLoadingRules{
                ExplicitPath:        kubeconfigPath,
                Precedence:          nil,
                MigrationRules:      nil,
                DoNotResolvePaths:   false,
                DefaultClientConfig: nil,
                WarnIfAllMissing:    false,
                Warner:              nil,
        }
}</span>

func (b *KubectlInstaller) buildConfigOverrides() *clientcmd.ConfigOverrides <span class="cov8" title="1">{
        overrides := &amp;clientcmd.ConfigOverrides{
                AuthInfo:        b.buildAuthInfo(),
                ClusterDefaults: b.buildCluster(),
                ClusterInfo:     b.buildCluster(),
                Context:         b.buildContext(),
                CurrentContext:  "",
                Timeout:         "",
        }
        if b.context != "" </span><span class="cov8" title="1">{
                overrides.CurrentContext = b.context
        }</span>

        <span class="cov8" title="1">return overrides</span>
}

func (b *KubectlInstaller) buildAuthInfo() api.AuthInfo <span class="cov8" title="1">{
        return api.AuthInfo{
                LocationOfOrigin:      "",
                ClientCertificate:     "",
                ClientCertificateData: nil,
                ClientKey:             "",
                ClientKeyData:         nil,
                Token:                 "",
                TokenFile:             "",
                Impersonate:           "",
                ImpersonateUID:        "",
                ImpersonateGroups:     nil,
                ImpersonateUserExtra:  nil,
                Username:              "",
                Password:              "",
                AuthProvider:          nil,
                Exec:                  nil,
                Extensions:            nil,
        }
}</span>

func (b *KubectlInstaller) buildCluster() api.Cluster <span class="cov8" title="1">{
        return api.Cluster{
                LocationOfOrigin:         "",
                Server:                   "",
                TLSServerName:            "",
                InsecureSkipTLSVerify:    false,
                CertificateAuthority:     "",
                CertificateAuthorityData: nil,
                ProxyURL:                 "",
                DisableCompression:       false,
                Extensions:               nil,
        }
}</span>

func (b *KubectlInstaller) buildContext() api.Context <span class="cov8" title="1">{
        return api.Context{
                LocationOfOrigin: "",
                Cluster:          "",
                AuthInfo:         "",
                Namespace:        "",
                Extensions:       nil,
        }
}</span>

// applyCRD creates the ApplySet CRD from embedded YAML.
func (b *KubectlInstaller) applyCRD(ctx context.Context, client APIExtensionsClientInterface) error <span class="cov8" title="1">{
        var crd apiextensionsv1.CustomResourceDefinition

        err := yaml.Unmarshal(applySetCRDYAML, &amp;crd)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to unmarshal CRD yaml: %w", err)
        }</span>
        // Attempt create; if already exists attempt update (could race).
        <span class="cov8" title="1">_, err = client.Create(ctx, &amp;crd, metav1.CreateOptions{
                TypeMeta: metav1.TypeMeta{
                        Kind:       "",
                        APIVersion: "",
                },
                DryRun:          nil,
                FieldManager:    "",
                FieldValidation: "",
        })
        if err == nil </span><span class="cov8" title="1">{
                return nil
        }</span>
        <span class="cov8" title="1">if apierrors.IsAlreadyExists(err) </span><span class="cov0" title="0">{
                existing, getErr := client.Get(ctx, crd.Name, metav1.GetOptions{
                        TypeMeta: metav1.TypeMeta{
                                Kind:       "",
                                APIVersion: "",
                        },
                        ResourceVersion: "",
                })
                if getErr != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to get existing CRD for update: %w", getErr)
                }</span>

                <span class="cov0" title="0">crd.ResourceVersion = existing.ResourceVersion

                _, uerr := client.Update(ctx, &amp;crd, metav1.UpdateOptions{
                        TypeMeta: metav1.TypeMeta{
                                Kind:       "",
                                APIVersion: "",
                        },
                        DryRun:          nil,
                        FieldManager:    "",
                        FieldValidation: "",
                })
                if uerr != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to update CRD: %w", uerr)
                }</span>

                <span class="cov0" title="0">return nil</span>
        }

        <span class="cov8" title="1">return fmt.Errorf("failed to create CRD: %w", err)</span>
}

func (b *KubectlInstaller) waitForCRDEstablished(
        ctx context.Context,
        client APIExtensionsClientInterface,
        name string,
) error <span class="cov8" title="1">{
        // Poll every 500ms until Established=True or timeout
        const pollInterval = 500 * time.Millisecond

        err := wait.PollUntilContextTimeout(ctx, pollInterval, b.timeout, true,
                func(ctx context.Context) (bool, error) </span><span class="cov8" title="1">{
                        crd, err := client.Get(ctx, name, metav1.GetOptions{
                                TypeMeta: metav1.TypeMeta{
                                        Kind:       "",
                                        APIVersion: "",
                                },
                                ResourceVersion: "",
                        })
                        if err != nil </span><span class="cov8" title="1">{
                                if apierrors.IsNotFound(err) </span><span class="cov8" title="1">{
                                        return false, nil
                                }</span>

                                <span class="cov0" title="0">return false, fmt.Errorf("failed to get CRD: %w", err)</span>
                        }

                        <span class="cov0" title="0">for _, cond := range crd.Status.Conditions </span><span class="cov0" title="0">{
                                if cond.Type == apiextensionsv1.Established &amp;&amp; cond.Status == apiextensionsv1.ConditionTrue </span><span class="cov0" title="0">{
                                        return true, nil
                                }</span>

                                <span class="cov0" title="0">if cond.Type == apiextensionsv1.NamesAccepted &amp;&amp;
                                        cond.Status == apiextensionsv1.ConditionFalse &amp;&amp;
                                        cond.Reason == "MultipleNamesNotAllowed" </span><span class="cov0" title="0">{
                                        return false, fmt.Errorf("%w: %s", ErrCRDNameNotAccepted, cond.Message)
                                }</span>
                        }

                        <span class="cov0" title="0">return false, nil</span>
                })
        <span class="cov8" title="1">if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("failed to wait for CRD to be established: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (b *KubectlInstaller) applyApplySetCR(
        ctx context.Context,
        dyn DynamicClientInterface,
        name string,
) error <span class="cov8" title="1">{
        var applySetObj unstructured.Unstructured

        err := yaml.Unmarshal(applySetCRYAML, &amp;applySetObj.Object)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to unmarshal ApplySet CR yaml: %w", err)
        }</span>
        // Ensure GVK since yaml-&gt;map won't set it.
        <span class="cov8" title="1">applySetObj.SetGroupVersionKind(schema.GroupVersionKind{Group: "k8s.devantler.tech", Version: "v1", Kind: "ApplySet"})
        applySetObj.SetName(name)

        _, err = dyn.Create(ctx, &amp;applySetObj, metav1.CreateOptions{
                TypeMeta: metav1.TypeMeta{
                        Kind:       "",
                        APIVersion: "",
                },
                DryRun:          nil,
                FieldManager:    "",
                FieldValidation: "",
        })
        if err == nil </span><span class="cov8" title="1">{
                return nil
        }</span>
        <span class="cov8" title="1">if apierrors.IsAlreadyExists(err) </span><span class="cov0" title="0">{
                existing, getErr := dyn.Get(ctx, name, metav1.GetOptions{
                        TypeMeta: metav1.TypeMeta{
                                Kind:       "",
                                APIVersion: "",
                        },
                        ResourceVersion: "",
                })
                if getErr != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to get existing ApplySet: %w", getErr)
                }</span>

                <span class="cov0" title="0">applySetObj.SetResourceVersion(existing.GetResourceVersion())

                _, uerr := dyn.Update(ctx, &amp;applySetObj, metav1.UpdateOptions{
                        TypeMeta: metav1.TypeMeta{
                                Kind:       "",
                                APIVersion: "",
                        },
                        DryRun:          nil,
                        FieldManager:    "",
                        FieldValidation: "",
                })
                if uerr != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to update ApplySet: %w", uerr)
                }</span>

                <span class="cov0" title="0">return nil</span>
        }

        <span class="cov8" title="1">return fmt.Errorf("failed to create ApplySet CR: %w", err)</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package kubectlinstaller

import (
        "context"

        apiextensionsv1 "k8s.io/apiextensions-apiserver/pkg/apis/apiextensions/v1"
        apiextensionsclient "k8s.io/apiextensions-apiserver/pkg/client/clientset/clientset"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "k8s.io/apimachinery/pkg/apis/meta/v1/unstructured"
        "k8s.io/apimachinery/pkg/runtime/schema"
        "k8s.io/client-go/dynamic"
        "k8s.io/client-go/rest"
)

// APIExtensionsClientInterface defines the interface for API extensions client operations.
type APIExtensionsClientInterface interface {
        Get(ctx context.Context, name string, opts metav1.GetOptions) (*apiextensionsv1.CustomResourceDefinition, error)
        Create(ctx context.Context, crd *apiextensionsv1.CustomResourceDefinition, opts metav1.CreateOptions) (*apiextensionsv1.CustomResourceDefinition, error)
        Update(ctx context.Context, crd *apiextensionsv1.CustomResourceDefinition, opts metav1.UpdateOptions) (*apiextensionsv1.CustomResourceDefinition, error)
        Delete(ctx context.Context, name string, opts metav1.DeleteOptions) error
}

// DynamicClientInterface defines the interface for dynamic client operations.
type DynamicClientInterface interface {
        Get(ctx context.Context, name string, opts metav1.GetOptions) (*unstructured.Unstructured, error)
        Create(ctx context.Context, obj *unstructured.Unstructured, opts metav1.CreateOptions) (*unstructured.Unstructured, error)
        Update(ctx context.Context, obj *unstructured.Unstructured, opts metav1.UpdateOptions) (*unstructured.Unstructured, error)
        Delete(ctx context.Context, name string, opts metav1.DeleteOptions) error
}

// ClientFactoryInterface defines the interface for creating Kubernetes clients.
type ClientFactoryInterface interface {
        CreateAPIExtensionsClient(config *rest.Config) (APIExtensionsClientInterface, error)
        CreateDynamicClient(config *rest.Config, gvr schema.GroupVersionResource) (DynamicClientInterface, error)
}

// defaultAPIExtensionsClient wraps the real API extensions client.
type defaultAPIExtensionsClient struct {
        client *apiextensionsclient.Clientset
}

func (c *defaultAPIExtensionsClient) Get(ctx context.Context, name string, opts metav1.GetOptions) (*apiextensionsv1.CustomResourceDefinition, error) <span class="cov8" title="1">{
        return c.client.ApiextensionsV1().CustomResourceDefinitions().Get(ctx, name, opts)
}</span>

func (c *defaultAPIExtensionsClient) Create(ctx context.Context, crd *apiextensionsv1.CustomResourceDefinition, opts metav1.CreateOptions) (*apiextensionsv1.CustomResourceDefinition, error) <span class="cov0" title="0">{
        return c.client.ApiextensionsV1().CustomResourceDefinitions().Create(ctx, crd, opts)
}</span>

func (c *defaultAPIExtensionsClient) Update(ctx context.Context, crd *apiextensionsv1.CustomResourceDefinition, opts metav1.UpdateOptions) (*apiextensionsv1.CustomResourceDefinition, error) <span class="cov0" title="0">{
        return c.client.ApiextensionsV1().CustomResourceDefinitions().Update(ctx, crd, opts)
}</span>

func (c *defaultAPIExtensionsClient) Delete(ctx context.Context, name string, opts metav1.DeleteOptions) error <span class="cov0" title="0">{
        return c.client.ApiextensionsV1().CustomResourceDefinitions().Delete(ctx, name, opts)
}</span>

// defaultDynamicClient wraps the real dynamic client.
type defaultDynamicClient struct {
        client dynamic.Interface
        gvr    schema.GroupVersionResource
}

func (c *defaultDynamicClient) Get(ctx context.Context, name string, opts metav1.GetOptions) (*unstructured.Unstructured, error) <span class="cov0" title="0">{
        return c.client.Resource(c.gvr).Get(ctx, name, opts)
}</span>

func (c *defaultDynamicClient) Create(ctx context.Context, obj *unstructured.Unstructured, opts metav1.CreateOptions) (*unstructured.Unstructured, error) <span class="cov0" title="0">{
        return c.client.Resource(c.gvr).Create(ctx, obj, opts)
}</span>

func (c *defaultDynamicClient) Update(ctx context.Context, obj *unstructured.Unstructured, opts metav1.UpdateOptions) (*unstructured.Unstructured, error) <span class="cov0" title="0">{
        return c.client.Resource(c.gvr).Update(ctx, obj, opts)
}</span>

func (c *defaultDynamicClient) Delete(ctx context.Context, name string, opts metav1.DeleteOptions) error <span class="cov0" title="0">{
        return c.client.Resource(c.gvr).Delete(ctx, name, opts)
}</span>

// defaultClientFactory creates real Kubernetes clients.
type defaultClientFactory struct{}

func (f *defaultClientFactory) CreateAPIExtensionsClient(config *rest.Config) (APIExtensionsClientInterface, error) <span class="cov8" title="1">{
        client, err := apiextensionsclient.NewForConfig(config)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return &amp;defaultAPIExtensionsClient{client: client}, nil</span>
}

func (f *defaultClientFactory) CreateDynamicClient(config *rest.Config, gvr schema.GroupVersionResource) (DynamicClientInterface, error) <span class="cov0" title="0">{
        client, err := dynamic.NewForConfig(config)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;defaultDynamicClient{client: client, gvr: gvr}, nil</span>
}

// NewDefaultClientFactory creates a new default client factory.
func NewDefaultClientFactory() ClientFactoryInterface <span class="cov8" title="1">{
        return &amp;defaultClientFactory{}
}</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
